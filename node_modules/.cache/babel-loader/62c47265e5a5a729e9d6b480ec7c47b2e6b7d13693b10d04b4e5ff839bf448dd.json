{"ast":null,"code":"export function isValidMove(board, from, to, turn, moveHistory) {\n  const piece = board[from.row][from.col];\n  if (!piece) return false; // No piece to move\n\n  const isWhite = piece === piece.toUpperCase();\n  const isBlack = !isWhite;\n\n  // Ensure the correct player is moving\n  if (turn === \"white\" && !isWhite || turn === \"black\" && isBlack) {\n    return false;\n  }\n  const targetPiece = board[to.row][to.col];\n  const isCapture = targetPiece !== \"\"; // If there's an opponent piece\n\n  // Prevent capturing own pieces\n  if (isCapture) {\n    const targetIsWhite = targetPiece === targetPiece.toUpperCase();\n    if (isWhite && targetIsWhite || isBlack && !targetIsWhite) {\n      return false;\n    }\n  }\n  const rowDiff = Math.abs(to.row - from.row);\n  const colDiff = Math.abs(to.col - from.col);\n\n  // PAWN MOVEMENT\n  if (piece.toLowerCase() === \"p\") {\n    const direction = isWhite ? -1 : 1;\n    const startRow = isWhite ? 6 : 1;\n\n    // Standard move (one step forward)\n    if (to.row === from.row + direction && to.col === from.col && !targetPiece) {\n      return true;\n    }\n\n    // Double move from starting position\n    if (from.row === startRow && to.row === from.row + 2 * direction && to.col === from.col && !board[to.row][to.col] && !board[from.row + direction][to.col]) {\n      return true;\n    }\n\n    // Capture diagonally\n    if (to.row === from.row + direction && Math.abs(to.col - from.col) === 1 && isCapture) {\n      return true;\n    }\n  }\n\n  // ROOK MOVEMENT\n  if (piece.toLowerCase() === \"r\") {\n    if (from.row === to.row) {\n      for (let col = Math.min(from.col, to.col) + 1; col < Math.max(from.col, to.col); col++) {\n        if (board[from.row][col]) return false;\n      }\n      return true;\n    }\n    if (from.col === to.col) {\n      for (let row = Math.min(from.row, to.row) + 1; row < Math.max(from.row, to.row); row++) {\n        if (board[row][from.col]) return false;\n      }\n      return true;\n    }\n  }\n\n  // KNIGHT MOVEMENT\n  if (piece.toLowerCase() === \"n\") {\n    if (rowDiff === 2 && colDiff === 1 || rowDiff === 1 && colDiff === 2) {\n      return true;\n    }\n  }\n\n  // BISHOP MOVEMENT\n  if (piece.toLowerCase() === \"b\") {\n    if (rowDiff === colDiff) {\n      let rowStep = to.row > from.row ? 1 : -1;\n      let colStep = to.col > from.col ? 1 : -1;\n      let row = from.row + rowStep;\n      let col = from.col + colStep;\n      while (row !== to.row && col !== to.col) {\n        if (board[row][col]) return false;\n        row += rowStep;\n        col += colStep;\n      }\n      return true;\n    }\n  }\n\n  // QUEEN MOVEMENT (Fixed)\n  if (piece.toLowerCase() === \"q\") {\n    if (from.row === to.row || from.col === to.col) {\n      return isValidMove(board, from, to, turn, moveHistory); // Rook-like move\n    }\n    if (Math.abs(to.row - from.row) === Math.abs(to.col - from.col)) {\n      return isValidMove(board, from, to, turn, moveHistory); // Bishop-like move\n    }\n    return false;\n  }\n\n  // KING MOVEMENT\n  if (piece.toLowerCase() === \"k\") {\n    if (rowDiff <= 1 && colDiff <= 1) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Function to check if a player is in check.\n */\nexport function isKingInCheck(board, turn) {\n  let kingPosition = null;\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      if (board[row][col] === (turn === \"white\" ? \"K\" : \"k\")) {\n        kingPosition = {\n          row,\n          col\n        };\n        break;\n      }\n    }\n  }\n  if (!kingPosition) return false;\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece && isValidMove(board, {\n        row,\n        col\n      }, kingPosition, turn === \"white\" ? \"black\" : \"white\")) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Function to determine if the game is over (checkmate or stalemate).\n */\nexport function isGameOver(board, turn) {\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      if (board[row][col] && (turn === \"white\" && board[row][col] === board[row][col].toUpperCase() || turn === \"black\" && board[row][col] === board[row][col].toLowerCase())) {\n        for (let targetRow = 0; targetRow < 8; targetRow++) {\n          for (let targetCol = 0; targetCol < 8; targetCol++) {\n            if (isValidMove(board, {\n              row,\n              col\n            }, {\n              row: targetRow,\n              col: targetCol\n            }, turn)) {\n              return false;\n            }\n          }\n        }\n      }\n    }\n  }\n  return true;\n}","map":{"version":3,"names":["isValidMove","board","from","to","turn","moveHistory","piece","row","col","isWhite","toUpperCase","isBlack","targetPiece","isCapture","targetIsWhite","rowDiff","Math","abs","colDiff","toLowerCase","direction","startRow","min","max","rowStep","colStep","isKingInCheck","kingPosition","isGameOver","targetRow","targetCol"],"sources":["/Users/mikeb/CV_projects/chess-app/src/utils/chessLogic.js"],"sourcesContent":["export function isValidMove(board, from, to, turn, moveHistory) {\n    const piece = board[from.row][from.col];\n    if (!piece) return false; // No piece to move\n  \n    const isWhite = piece === piece.toUpperCase();\n    const isBlack = !isWhite;\n  \n    // Ensure the correct player is moving\n    if ((turn === \"white\" && !isWhite) || (turn === \"black\" && isBlack)) {\n      return false;\n    }\n  \n    const targetPiece = board[to.row][to.col];\n    const isCapture = targetPiece !== \"\"; // If there's an opponent piece\n  \n    // Prevent capturing own pieces\n    if (isCapture) {\n      const targetIsWhite = targetPiece === targetPiece.toUpperCase();\n      if ((isWhite && targetIsWhite) || (isBlack && !targetIsWhite)) {\n        return false;\n      }\n    }\n  \n    const rowDiff = Math.abs(to.row - from.row);\n    const colDiff = Math.abs(to.col - from.col);\n  \n    // PAWN MOVEMENT\n    if (piece.toLowerCase() === \"p\") {\n      const direction = isWhite ? -1 : 1;\n      const startRow = isWhite ? 6 : 1;\n  \n      // Standard move (one step forward)\n      if (to.row === from.row + direction && to.col === from.col && !targetPiece) {\n        return true;\n      }\n  \n      // Double move from starting position\n      if (from.row === startRow && to.row === from.row + 2 * direction && to.col === from.col && !board[to.row][to.col] && !board[from.row + direction][to.col]) {\n        return true;\n      }\n  \n      // Capture diagonally\n      if (to.row === from.row + direction && Math.abs(to.col - from.col) === 1 && isCapture) {\n        return true;\n      }\n    }\n  \n    // ROOK MOVEMENT\n    if (piece.toLowerCase() === \"r\") {\n      if (from.row === to.row) {\n        for (let col = Math.min(from.col, to.col) + 1; col < Math.max(from.col, to.col); col++) {\n          if (board[from.row][col]) return false;\n        }\n        return true;\n      }\n      if (from.col === to.col) {\n        for (let row = Math.min(from.row, to.row) + 1; row < Math.max(from.row, to.row); row++) {\n          if (board[row][from.col]) return false;\n        }\n        return true;\n      }\n    }\n  \n    // KNIGHT MOVEMENT\n    if (piece.toLowerCase() === \"n\") {\n      if ((rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2)) {\n        return true;\n      }\n    }\n  \n    // BISHOP MOVEMENT\n    if (piece.toLowerCase() === \"b\") {\n      if (rowDiff === colDiff) {\n        let rowStep = to.row > from.row ? 1 : -1;\n        let colStep = to.col > from.col ? 1 : -1;\n        let row = from.row + rowStep;\n        let col = from.col + colStep;\n        while (row !== to.row && col !== to.col) {\n          if (board[row][col]) return false;\n          row += rowStep;\n          col += colStep;\n        }\n        return true;\n      }\n    }\n  \n    // QUEEN MOVEMENT (Fixed)\n    if (piece.toLowerCase() === \"q\") {\n      if (from.row === to.row || from.col === to.col) {\n        return isValidMove(board, from, to, turn, moveHistory); // Rook-like move\n      }\n      if (Math.abs(to.row - from.row) === Math.abs(to.col - from.col)) {\n        return isValidMove(board, from, to, turn, moveHistory); // Bishop-like move\n      }\n      return false;\n    }\n  \n    // KING MOVEMENT\n    if (piece.toLowerCase() === \"k\") {\n      if (rowDiff <= 1 && colDiff <= 1) {\n        return true;\n      }\n    }\n  \n    return false;\n  }\n  \n  /**\n   * Function to check if a player is in check.\n   */\n  export function isKingInCheck(board, turn) {\n    let kingPosition = null;\n    for (let row = 0; row < 8; row++) {\n      for (let col = 0; col < 8; col++) {\n        if (board[row][col] === (turn === \"white\" ? \"K\" : \"k\")) {\n          kingPosition = { row, col };\n          break;\n        }\n      }\n    }\n    if (!kingPosition) return false;\n  \n    for (let row = 0; row < 8; row++) {\n      for (let col = 0; col < 8; col++) {\n        const piece = board[row][col];\n        if (piece && isValidMove(board, { row, col }, kingPosition, turn === \"white\" ? \"black\" : \"white\")) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  \n  /**\n   * Function to determine if the game is over (checkmate or stalemate).\n   */\n  export function isGameOver(board, turn) {\n    for (let row = 0; row < 8; row++) {\n      for (let col = 0; col < 8; col++) {\n        if (board[row][col] && ((turn === \"white\" && board[row][col] === board[row][col].toUpperCase()) || (turn === \"black\" && board[row][col] === board[row][col].toLowerCase()))) {\n          for (let targetRow = 0; targetRow < 8; targetRow++) {\n            for (let targetCol = 0; targetCol < 8; targetCol++) {\n              if (isValidMove(board, { row, col }, { row: targetRow, col: targetCol }, turn)) {\n                return false;\n              }\n            }\n          }\n        }\n      }\n    }\n    return true;\n  }\n  "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}