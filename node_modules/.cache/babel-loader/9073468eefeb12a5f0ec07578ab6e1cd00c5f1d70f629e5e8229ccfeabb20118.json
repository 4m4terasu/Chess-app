{"ast":null,"code":"export function isValidMove(board, from, to, turn, moveHistory, skipCheck = false) {\n  const piece = board[from.row][from.col];\n  if (!piece) return false; // No piece to move\n\n  const isWhite = piece === piece.toUpperCase();\n  const isBlack = !isWhite;\n\n  // Ensure correct player turn: white pieces (uppercase) only move on white's turn, black (lowercase) on black's turn.\n  if (turn === \"white\" && !isWhite || turn === \"black\" && !isBlack) {\n    return false;\n  }\n  const targetPiece = board[to.row][to.col];\n  const isCapture = targetPiece !== \"\";\n\n  // Prevent capturing your own pieces.\n  if (isCapture) {\n    const targetIsWhite = targetPiece === targetPiece.toUpperCase();\n    if (isWhite && targetIsWhite || isBlack && !targetIsWhite) {\n      return false;\n    }\n  }\n\n  // Prevent moves that leave your king in check.\n  if (!skipCheck && wouldMoveCauseCheck(board, from, to, turn)) {\n    return false;\n  }\n  const rowDiff = Math.abs(to.row - from.row);\n  const colDiff = Math.abs(to.col - from.col);\n\n  // ───────────── PAWN MOVEMENT ─────────────\n  if (piece.toLowerCase() === \"p\") {\n    const direction = isWhite ? -1 : 1;\n    const startRow = isWhite ? 6 : 1;\n\n    // Standard one-step forward.\n    if (to.row === from.row + direction && to.col === from.col && !targetPiece) {\n      return true;\n    }\n\n    // Double move from starting position.\n    if (from.row === startRow && to.row === from.row + 2 * direction && to.col === from.col && !board[to.row][to.col] && !board[from.row + direction][to.col]) {\n      return true;\n    }\n\n    // Capture diagonally.\n    if (to.row === from.row + direction && Math.abs(to.col - from.col) === 1 && isCapture) {\n      return true;\n    }\n\n    // En passant capture.\n    if (moveHistory.length > 0) {\n      const lastMove = moveHistory[moveHistory.length - 1];\n      if (lastMove.piece.toLowerCase() === \"p\" && Math.abs(lastMove.from.row - lastMove.to.row) === 2) {\n        if (to.row === lastMove.to.row + direction && Math.abs(to.col - from.col) === 1 && to.col === lastMove.to.col) {\n          return true;\n        }\n      }\n    }\n  }\n\n  // ───────────── ROOK MOVEMENT ─────────────\n  if (piece.toLowerCase() === \"r\") {\n    if (from.row === to.row) {\n      for (let col = Math.min(from.col, to.col) + 1; col < Math.max(from.col, to.col); col++) {\n        if (board[from.row][col]) return false;\n      }\n      return true;\n    }\n    if (from.col === to.col) {\n      for (let row = Math.min(from.row, to.row) + 1; row < Math.max(from.row, to.row); row++) {\n        if (board[row][from.col]) return false;\n      }\n      return true;\n    }\n  }\n\n  // ───────────── KNIGHT MOVEMENT ─────────────\n  if (piece.toLowerCase() === \"n\") {\n    if (rowDiff === 2 && colDiff === 1 || rowDiff === 1 && colDiff === 2) {\n      return true;\n    }\n  }\n\n  // ───────────── BISHOP MOVEMENT ─────────────\n  if (piece.toLowerCase() === \"b\") {\n    if (rowDiff === colDiff) {\n      let rowStep = to.row > from.row ? 1 : -1;\n      let colStep = to.col > from.col ? 1 : -1;\n      let row = from.row + rowStep;\n      let col = from.col + colStep;\n      while (row !== to.row && col !== to.col) {\n        if (board[row][col]) return false;\n        row += rowStep;\n        col += colStep;\n      }\n      return true;\n    }\n  }\n\n  // ───────────── QUEEN MOVEMENT ─────────────\n  if (piece.toLowerCase() === \"q\") {\n    // Rook-like movement.\n    if (from.row === to.row) {\n      for (let col = Math.min(from.col, to.col) + 1; col < Math.max(from.col, to.col); col++) {\n        if (board[from.row][col]) return false;\n      }\n      return true;\n    }\n    if (from.col === to.col) {\n      for (let row = Math.min(from.row, to.row) + 1; row < Math.max(from.row, to.row); row++) {\n        if (board[row][from.col]) return false;\n      }\n      return true;\n    }\n    // Bishop-like movement.\n    if (Math.abs(to.row - from.row) === Math.abs(to.col - from.col)) {\n      let rowStep = to.row > from.row ? 1 : -1;\n      let colStep = to.col > from.col ? 1 : -1;\n      let row = from.row + rowStep;\n      let col = from.col + colStep;\n      while (row !== to.row && col !== to.col) {\n        if (board[row][col]) return false;\n        row += rowStep;\n        col += colStep;\n      }\n      return true;\n    }\n    return false;\n  }\n\n  // ───────────── KING MOVEMENT ─────────────\n  if (piece.toLowerCase() === \"k\") {\n    // Normal king move: one square in any direction.\n    if (rowDiff <= 1 && colDiff <= 1) {\n      return true;\n    }\n\n    // When simulating moves (skipCheck true), do not allow castling.\n    if (skipCheck) return false;\n\n    // Castling: King moves two squares horizontally.\n    if (rowDiff === 0 && colDiff === 2) {\n      // Check that king is in its starting square.\n      if (turn === \"white\" && (from.row !== 7 || from.col !== 4)) return false;\n      if (turn === \"black\" && (from.row !== 0 || from.col !== 4)) return false;\n\n      // Determine the rook's column and verify that the rook is in its starting position.\n      const rookCol = to.col > from.col ? 7 : 0;\n      if (turn === \"white\") {\n        if (to.col > from.col) {\n          if (board[7][7] !== \"R\") return false;\n        } else {\n          if (board[7][0] !== \"R\") return false;\n        }\n      } else {\n        if (to.col > from.col) {\n          if (board[0][7] !== \"r\") return false;\n        } else {\n          if (board[0][0] !== \"r\") return false;\n        }\n      }\n\n      // Check that the squares between the king and the rook are empty.\n      let betweenCols;\n      if (to.col > from.col) {\n        betweenCols = [from.col + 1, from.col + 2];\n      } else {\n        betweenCols = [from.col - 1, from.col - 2, from.col - 3];\n      }\n      for (let col of betweenCols) {\n        if (board[from.row][col]) return false;\n      }\n\n      // Ensure the king does not pass through or land on a square that is attacked.\n      const step = to.col > from.col ? 1 : -1;\n      for (let i = 0; i <= 2; i++) {\n        const intermediateCol = from.col + i * step;\n        const simulatedBoard = board.map(row => row.slice());\n        simulatedBoard[from.row][intermediateCol] = piece;\n        simulatedBoard[from.row][from.col] = \"\";\n        if (isKingInCheck(simulatedBoard, turn)) return false;\n      }\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Helper function: Simulate the move and check if it leaves the king in check.\n */\nfunction wouldMoveCauseCheck(board, from, to, turn) {\n  const newBoard = board.map(row => row.slice());\n  newBoard[to.row][to.col] = newBoard[from.row][from.col];\n  newBoard[from.row][from.col] = \"\";\n  return isKingInCheck(newBoard, turn);\n}\n\n/**\n * Checks if the king of the given turn is in check.\n * When checking, we call isValidMove with skipCheck=true to avoid recursion.\n */\nexport function isKingInCheck(board, turn) {\n  let kingPosition = null;\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      if (board[row][col] === (turn === \"white\" ? \"K\" : \"k\")) {\n        kingPosition = {\n          row,\n          col\n        };\n        break;\n      }\n    }\n    if (kingPosition) break;\n  }\n  if (!kingPosition) return false;\n\n  // Check if any opponent piece can attack the king.\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece && isValidMove(board, {\n        row,\n        col\n      }, kingPosition, turn === \"white\" ? \"black\" : \"white\", [], true // Skip king safety check to prevent recursion.\n      )) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Determines if the game is over (checkmate or stalemate).\n */\nexport function isGameOver(board, turn) {\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      if (board[row][col] && (turn === \"white\" && board[row][col] === board[row][col].toUpperCase() || turn === \"black\" && board[row][col] === board[row][col].toLowerCase())) {\n        for (let targetRow = 0; targetRow < 8; targetRow++) {\n          for (let targetCol = 0; targetCol < 8; targetCol++) {\n            if (isValidMove(board, {\n              row,\n              col\n            }, {\n              row: targetRow,\n              col: targetCol\n            }, turn, [])) {\n              return false;\n            }\n          }\n        }\n      }\n    }\n  }\n  return true;\n}","map":{"version":3,"names":["isValidMove","board","from","to","turn","moveHistory","skipCheck","piece","row","col","isWhite","toUpperCase","isBlack","targetPiece","isCapture","targetIsWhite","wouldMoveCauseCheck","rowDiff","Math","abs","colDiff","toLowerCase","direction","startRow","length","lastMove","min","max","rowStep","colStep","rookCol","betweenCols","step","i","intermediateCol","simulatedBoard","map","slice","isKingInCheck","newBoard","kingPosition","isGameOver","targetRow","targetCol"],"sources":["/Users/mikeb/CV_projects/chess-app/src/utils/chessLogic.js"],"sourcesContent":["export function isValidMove(board, from, to, turn, moveHistory, skipCheck = false) {\n    const piece = board[from.row][from.col];\n    if (!piece) return false; // No piece to move\n  \n    const isWhite = piece === piece.toUpperCase();\n    const isBlack = !isWhite;\n  \n    // Ensure correct player turn: white pieces (uppercase) only move on white's turn, black (lowercase) on black's turn.\n    if ((turn === \"white\" && !isWhite) || (turn === \"black\" && !isBlack)) {\n      return false;\n    }\n  \n    const targetPiece = board[to.row][to.col];\n    const isCapture = targetPiece !== \"\";\n  \n    // Prevent capturing your own pieces.\n    if (isCapture) {\n      const targetIsWhite = targetPiece === targetPiece.toUpperCase();\n      if ((isWhite && targetIsWhite) || (isBlack && !targetIsWhite)) {\n        return false;\n      }\n    }\n  \n    // Prevent moves that leave your king in check.\n    if (!skipCheck && wouldMoveCauseCheck(board, from, to, turn)) {\n      return false;\n    }\n  \n    const rowDiff = Math.abs(to.row - from.row);\n    const colDiff = Math.abs(to.col - from.col);\n  \n    // ───────────── PAWN MOVEMENT ─────────────\n    if (piece.toLowerCase() === \"p\") {\n      const direction = isWhite ? -1 : 1;\n      const startRow = isWhite ? 6 : 1;\n  \n      // Standard one-step forward.\n      if (to.row === from.row + direction && to.col === from.col && !targetPiece) {\n        return true;\n      }\n  \n      // Double move from starting position.\n      if (\n        from.row === startRow &&\n        to.row === from.row + 2 * direction &&\n        to.col === from.col &&\n        !board[to.row][to.col] &&\n        !board[from.row + direction][to.col]\n      ) {\n        return true;\n      }\n  \n      // Capture diagonally.\n      if (to.row === from.row + direction && Math.abs(to.col - from.col) === 1 && isCapture) {\n        return true;\n      }\n  \n      // En passant capture.\n      if (moveHistory.length > 0) {\n        const lastMove = moveHistory[moveHistory.length - 1];\n        if (lastMove.piece.toLowerCase() === \"p\" && Math.abs(lastMove.from.row - lastMove.to.row) === 2) {\n          if (\n            to.row === lastMove.to.row + direction &&\n            Math.abs(to.col - from.col) === 1 &&\n            to.col === lastMove.to.col\n          ) {\n            return true;\n          }\n        }\n      }\n    }\n  \n    // ───────────── ROOK MOVEMENT ─────────────\n    if (piece.toLowerCase() === \"r\") {\n      if (from.row === to.row) {\n        for (let col = Math.min(from.col, to.col) + 1; col < Math.max(from.col, to.col); col++) {\n          if (board[from.row][col]) return false;\n        }\n        return true;\n      }\n      if (from.col === to.col) {\n        for (let row = Math.min(from.row, to.row) + 1; row < Math.max(from.row, to.row); row++) {\n          if (board[row][from.col]) return false;\n        }\n        return true;\n      }\n    }\n  \n    // ───────────── KNIGHT MOVEMENT ─────────────\n    if (piece.toLowerCase() === \"n\") {\n      if ((rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2)) {\n        return true;\n      }\n    }\n  \n    // ───────────── BISHOP MOVEMENT ─────────────\n    if (piece.toLowerCase() === \"b\") {\n      if (rowDiff === colDiff) {\n        let rowStep = to.row > from.row ? 1 : -1;\n        let colStep = to.col > from.col ? 1 : -1;\n        let row = from.row + rowStep;\n        let col = from.col + colStep;\n        while (row !== to.row && col !== to.col) {\n          if (board[row][col]) return false;\n          row += rowStep;\n          col += colStep;\n        }\n        return true;\n      }\n    }\n  \n    // ───────────── QUEEN MOVEMENT ─────────────\n    if (piece.toLowerCase() === \"q\") {\n      // Rook-like movement.\n      if (from.row === to.row) {\n        for (let col = Math.min(from.col, to.col) + 1; col < Math.max(from.col, to.col); col++) {\n          if (board[from.row][col]) return false;\n        }\n        return true;\n      }\n      if (from.col === to.col) {\n        for (let row = Math.min(from.row, to.row) + 1; row < Math.max(from.row, to.row); row++) {\n          if (board[row][from.col]) return false;\n        }\n        return true;\n      }\n      // Bishop-like movement.\n      if (Math.abs(to.row - from.row) === Math.abs(to.col - from.col)) {\n        let rowStep = to.row > from.row ? 1 : -1;\n        let colStep = to.col > from.col ? 1 : -1;\n        let row = from.row + rowStep;\n        let col = from.col + colStep;\n        while (row !== to.row && col !== to.col) {\n          if (board[row][col]) return false;\n          row += rowStep;\n          col += colStep;\n        }\n        return true;\n      }\n      return false;\n    }\n  \n    // ───────────── KING MOVEMENT ─────────────\n    if (piece.toLowerCase() === \"k\") {\n      // Normal king move: one square in any direction.\n      if (rowDiff <= 1 && colDiff <= 1) {\n        return true;\n      }\n  \n      // When simulating moves (skipCheck true), do not allow castling.\n      if (skipCheck) return false;\n  \n      // Castling: King moves two squares horizontally.\n      if (rowDiff === 0 && colDiff === 2) {\n        // Check that king is in its starting square.\n        if (turn === \"white\" && (from.row !== 7 || from.col !== 4)) return false;\n        if (turn === \"black\" && (from.row !== 0 || from.col !== 4)) return false;\n  \n        // Determine the rook's column and verify that the rook is in its starting position.\n        const rookCol = to.col > from.col ? 7 : 0;\n        if (turn === \"white\") {\n          if (to.col > from.col) {\n            if (board[7][7] !== \"R\") return false;\n          } else {\n            if (board[7][0] !== \"R\") return false;\n          }\n        } else {\n          if (to.col > from.col) {\n            if (board[0][7] !== \"r\") return false;\n          } else {\n            if (board[0][0] !== \"r\") return false;\n          }\n        }\n  \n        // Check that the squares between the king and the rook are empty.\n        let betweenCols;\n        if (to.col > from.col) {\n          betweenCols = [from.col + 1, from.col + 2];\n        } else {\n          betweenCols = [from.col - 1, from.col - 2, from.col - 3];\n        }\n        for (let col of betweenCols) {\n          if (board[from.row][col]) return false;\n        }\n  \n        // Ensure the king does not pass through or land on a square that is attacked.\n        const step = to.col > from.col ? 1 : -1;\n        for (let i = 0; i <= 2; i++) {\n          const intermediateCol = from.col + i * step;\n          const simulatedBoard = board.map(row => row.slice());\n          simulatedBoard[from.row][intermediateCol] = piece;\n          simulatedBoard[from.row][from.col] = \"\";\n          if (isKingInCheck(simulatedBoard, turn)) return false;\n        }\n        return true;\n      }\n    }\n  \n    return false;\n  }\n  \n  /**\n   * Helper function: Simulate the move and check if it leaves the king in check.\n   */\n  function wouldMoveCauseCheck(board, from, to, turn) {\n    const newBoard = board.map((row) => row.slice());\n    newBoard[to.row][to.col] = newBoard[from.row][from.col];\n    newBoard[from.row][from.col] = \"\";\n    return isKingInCheck(newBoard, turn);\n  }\n  \n  /**\n   * Checks if the king of the given turn is in check.\n   * When checking, we call isValidMove with skipCheck=true to avoid recursion.\n   */\n  export function isKingInCheck(board, turn) {\n    let kingPosition = null;\n    for (let row = 0; row < 8; row++) {\n      for (let col = 0; col < 8; col++) {\n        if (board[row][col] === (turn === \"white\" ? \"K\" : \"k\")) {\n          kingPosition = { row, col };\n          break;\n        }\n      }\n      if (kingPosition) break;\n    }\n    if (!kingPosition) return false;\n  \n    // Check if any opponent piece can attack the king.\n    for (let row = 0; row < 8; row++) {\n      for (let col = 0; col < 8; col++) {\n        const piece = board[row][col];\n        if (\n          piece &&\n          isValidMove(\n            board,\n            { row, col },\n            kingPosition,\n            turn === \"white\" ? \"black\" : \"white\",\n            [],\n            true // Skip king safety check to prevent recursion.\n          )\n        ) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  \n  /**\n   * Determines if the game is over (checkmate or stalemate).\n   */\n  export function isGameOver(board, turn) {\n    for (let row = 0; row < 8; row++) {\n      for (let col = 0; col < 8; col++) {\n        if (\n          board[row][col] &&\n          ((turn === \"white\" && board[row][col] === board[row][col].toUpperCase()) ||\n            (turn === \"black\" && board[row][col] === board[row][col].toLowerCase()))\n        ) {\n          for (let targetRow = 0; targetRow < 8; targetRow++) {\n            for (let targetCol = 0; targetCol < 8; targetCol++) {\n              if (isValidMove(board, { row, col }, { row: targetRow, col: targetCol }, turn, [])) {\n                return false;\n              }\n            }\n          }\n        }\n      }\n    }\n    return true;\n  }\n  "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}