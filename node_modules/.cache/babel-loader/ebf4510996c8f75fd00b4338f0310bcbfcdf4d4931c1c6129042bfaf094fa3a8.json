{"ast":null,"code":"export function isValidMove(board, from, to, turn) {\n  const piece = board[from.row][from.col];\n  if (!piece) return false; // No piece to move\n\n  const isWhite = piece === piece.toUpperCase();\n  const isBlack = !isWhite;\n\n  // Check if it's the correct player's turn\n  if (turn === \"white\" && !isWhite || turn === \"black\" && isBlack) {\n    return false; // It's not the player's turn\n  }\n  const targetPiece = board[to.row][to.col];\n  const isCapture = targetPiece !== \"\"; // If there's an opposing piece to capture\n\n  // Pawn movement (White moves up, Black moves down)\n  if (piece.toLowerCase() === \"p\") {\n    const direction = isWhite ? -1 : 1;\n    const initialRow = isWhite ? 6 : 1; // White pawns start at row 6, black pawns at row 1\n\n    // Pawn move: Move forward one square\n    if (to.row === from.row + direction && to.col === from.col && !board[to.row][to.col]) {\n      return true;\n    }\n\n    // Pawn capture: Diagonal move to capture an opponent's piece\n    if (to.row === from.row + direction && Math.abs(to.col - from.col) === 1 && isCapture) {\n      return true;\n    }\n\n    // Pawn initial double move (only from its starting position)\n    if (from.row === initialRow && to.row === from.row + 2 * direction && to.col === from.col && !board[to.row][to.col]) {\n      return true;\n    }\n  }\n\n  // Rook movement (straight lines horizontally or vertically)\n  if (piece.toLowerCase() === \"r\") {\n    if (from.row === to.row) {\n      for (let col = Math.min(from.col, to.col) + 1; col < Math.max(from.col, to.col); col++) {\n        if (board[from.row][col]) return false; // Blocked by another piece\n      }\n      return true;\n    }\n    if (from.col === to.col) {\n      for (let row = Math.min(from.row, to.row) + 1; row < Math.max(from.row, to.row); row++) {\n        if (board[row][from.col]) return false; // Blocked by another piece\n      }\n      return true;\n    }\n  }\n\n  // Knight movement (L-shape: 2 squares in one direction and 1 in another)\n  if (piece.toLowerCase() === \"n\") {\n    const rowDiff = Math.abs(to.row - from.row);\n    const colDiff = Math.abs(to.col - from.col);\n    if (rowDiff === 2 && colDiff === 1 || rowDiff === 1 && colDiff === 2) {\n      return true;\n    }\n  }\n\n  // Bishop movement (diagonal only)\n  if (piece.toLowerCase() === \"b\") {\n    const rowDiff = Math.abs(to.row - from.row);\n    const colDiff = Math.abs(to.col - from.col);\n    if (rowDiff === colDiff) {\n      // Check if there are any pieces blocking the path\n      let rowStep = to.row > from.row ? 1 : -1;\n      let colStep = to.col > from.col ? 1 : -1;\n      let row = from.row + rowStep;\n      let col = from.col + colStep;\n      while (row !== to.row && col !== to.col) {\n        if (board[row][col]) return false; // Blocked by another piece\n        row += rowStep;\n        col += colStep;\n      }\n      return true;\n    }\n  }\n\n  // Queen movement (combination of rook and bishop)\n  if (piece.toLowerCase() === \"q\") {\n    if (from.row === to.row || from.col === to.col) {\n      return isValidMove(board, from, to, turn); // Reuse the rook logic\n    }\n    return isValidMove(board, from, to, turn); // Reuse the bishop logic\n  }\n\n  // King movement (one square in any direction)\n  if (piece.toLowerCase() === \"k\") {\n    const rowDiff = Math.abs(to.row - from.row);\n    const colDiff = Math.abs(to.col - from.col);\n    if (rowDiff <= 1 && colDiff <= 1) {\n      return true;\n    }\n  }\n  return false; // Invalid move\n}","map":{"version":3,"names":["isValidMove","board","from","to","turn","piece","row","col","isWhite","toUpperCase","isBlack","targetPiece","isCapture","toLowerCase","direction","initialRow","Math","abs","min","max","rowDiff","colDiff","rowStep","colStep"],"sources":["/Users/mikeb/CV_projects/chess-app/src/utils/chessLogic.js"],"sourcesContent":["export function isValidMove(board, from, to, turn) {\n    const piece = board[from.row][from.col];\n    if (!piece) return false;  // No piece to move\n  \n    const isWhite = piece === piece.toUpperCase();\n    const isBlack = !isWhite;\n  \n    // Check if it's the correct player's turn\n    if ((turn === \"white\" && !isWhite) || (turn === \"black\" && isBlack)) {\n      return false;  // It's not the player's turn\n    }\n  \n    const targetPiece = board[to.row][to.col];\n    const isCapture = targetPiece !== \"\";  // If there's an opposing piece to capture\n  \n    // Pawn movement (White moves up, Black moves down)\n    if (piece.toLowerCase() === \"p\") {\n      const direction = isWhite ? -1 : 1;\n      const initialRow = isWhite ? 6 : 1; // White pawns start at row 6, black pawns at row 1\n  \n      // Pawn move: Move forward one square\n      if (to.row === from.row + direction && to.col === from.col && !board[to.row][to.col]) {\n        return true;\n      }\n  \n      // Pawn capture: Diagonal move to capture an opponent's piece\n      if (to.row === from.row + direction && Math.abs(to.col - from.col) === 1 && isCapture) {\n        return true;\n      }\n  \n      // Pawn initial double move (only from its starting position)\n      if (from.row === initialRow && to.row === from.row + 2 * direction && to.col === from.col && !board[to.row][to.col]) {\n        return true;\n      }\n    }\n  \n    // Rook movement (straight lines horizontally or vertically)\n    if (piece.toLowerCase() === \"r\") {\n      if (from.row === to.row) {\n        for (let col = Math.min(from.col, to.col) + 1; col < Math.max(from.col, to.col); col++) {\n          if (board[from.row][col]) return false;  // Blocked by another piece\n        }\n        return true;\n      }\n      if (from.col === to.col) {\n        for (let row = Math.min(from.row, to.row) + 1; row < Math.max(from.row, to.row); row++) {\n          if (board[row][from.col]) return false;  // Blocked by another piece\n        }\n        return true;\n      }\n    }\n  \n    // Knight movement (L-shape: 2 squares in one direction and 1 in another)\n    if (piece.toLowerCase() === \"n\") {\n      const rowDiff = Math.abs(to.row - from.row);\n      const colDiff = Math.abs(to.col - from.col);\n      if ((rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2)) {\n        return true;\n      }\n    }\n  \n    // Bishop movement (diagonal only)\n    if (piece.toLowerCase() === \"b\") {\n      const rowDiff = Math.abs(to.row - from.row);\n      const colDiff = Math.abs(to.col - from.col);\n      if (rowDiff === colDiff) {\n        // Check if there are any pieces blocking the path\n        let rowStep = to.row > from.row ? 1 : -1;\n        let colStep = to.col > from.col ? 1 : -1;\n        let row = from.row + rowStep;\n        let col = from.col + colStep;\n        while (row !== to.row && col !== to.col) {\n          if (board[row][col]) return false;  // Blocked by another piece\n          row += rowStep;\n          col += colStep;\n        }\n        return true;\n      }\n    }\n  \n    // Queen movement (combination of rook and bishop)\n    if (piece.toLowerCase() === \"q\") {\n      if (from.row === to.row || from.col === to.col) {\n        return isValidMove(board, from, to, turn);  // Reuse the rook logic\n      }\n      return isValidMove(board, from, to, turn);  // Reuse the bishop logic\n    }\n  \n    // King movement (one square in any direction)\n    if (piece.toLowerCase() === \"k\") {\n      const rowDiff = Math.abs(to.row - from.row);\n      const colDiff = Math.abs(to.col - from.col);\n      if (rowDiff <= 1 && colDiff <= 1) {\n        return true;\n      }\n    }\n  \n    return false;  // Invalid move\n  }\n  "],"mappings":"AAAA,OAAO,SAASA,WAAWA,CAACC,KAAK,EAAEC,IAAI,EAAEC,EAAE,EAAEC,IAAI,EAAE;EAC/C,MAAMC,KAAK,GAAGJ,KAAK,CAACC,IAAI,CAACI,GAAG,CAAC,CAACJ,IAAI,CAACK,GAAG,CAAC;EACvC,IAAI,CAACF,KAAK,EAAE,OAAO,KAAK,CAAC,CAAE;;EAE3B,MAAMG,OAAO,GAAGH,KAAK,KAAKA,KAAK,CAACI,WAAW,CAAC,CAAC;EAC7C,MAAMC,OAAO,GAAG,CAACF,OAAO;;EAExB;EACA,IAAKJ,IAAI,KAAK,OAAO,IAAI,CAACI,OAAO,IAAMJ,IAAI,KAAK,OAAO,IAAIM,OAAQ,EAAE;IACnE,OAAO,KAAK,CAAC,CAAE;EACjB;EAEA,MAAMC,WAAW,GAAGV,KAAK,CAACE,EAAE,CAACG,GAAG,CAAC,CAACH,EAAE,CAACI,GAAG,CAAC;EACzC,MAAMK,SAAS,GAAGD,WAAW,KAAK,EAAE,CAAC,CAAE;;EAEvC;EACA,IAAIN,KAAK,CAACQ,WAAW,CAAC,CAAC,KAAK,GAAG,EAAE;IAC/B,MAAMC,SAAS,GAAGN,OAAO,GAAG,CAAC,CAAC,GAAG,CAAC;IAClC,MAAMO,UAAU,GAAGP,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;;IAEpC;IACA,IAAIL,EAAE,CAACG,GAAG,KAAKJ,IAAI,CAACI,GAAG,GAAGQ,SAAS,IAAIX,EAAE,CAACI,GAAG,KAAKL,IAAI,CAACK,GAAG,IAAI,CAACN,KAAK,CAACE,EAAE,CAACG,GAAG,CAAC,CAACH,EAAE,CAACI,GAAG,CAAC,EAAE;MACpF,OAAO,IAAI;IACb;;IAEA;IACA,IAAIJ,EAAE,CAACG,GAAG,KAAKJ,IAAI,CAACI,GAAG,GAAGQ,SAAS,IAAIE,IAAI,CAACC,GAAG,CAACd,EAAE,CAACI,GAAG,GAAGL,IAAI,CAACK,GAAG,CAAC,KAAK,CAAC,IAAIK,SAAS,EAAE;MACrF,OAAO,IAAI;IACb;;IAEA;IACA,IAAIV,IAAI,CAACI,GAAG,KAAKS,UAAU,IAAIZ,EAAE,CAACG,GAAG,KAAKJ,IAAI,CAACI,GAAG,GAAG,CAAC,GAAGQ,SAAS,IAAIX,EAAE,CAACI,GAAG,KAAKL,IAAI,CAACK,GAAG,IAAI,CAACN,KAAK,CAACE,EAAE,CAACG,GAAG,CAAC,CAACH,EAAE,CAACI,GAAG,CAAC,EAAE;MACnH,OAAO,IAAI;IACb;EACF;;EAEA;EACA,IAAIF,KAAK,CAACQ,WAAW,CAAC,CAAC,KAAK,GAAG,EAAE;IAC/B,IAAIX,IAAI,CAACI,GAAG,KAAKH,EAAE,CAACG,GAAG,EAAE;MACvB,KAAK,IAAIC,GAAG,GAAGS,IAAI,CAACE,GAAG,CAAChB,IAAI,CAACK,GAAG,EAAEJ,EAAE,CAACI,GAAG,CAAC,GAAG,CAAC,EAAEA,GAAG,GAAGS,IAAI,CAACG,GAAG,CAACjB,IAAI,CAACK,GAAG,EAAEJ,EAAE,CAACI,GAAG,CAAC,EAAEA,GAAG,EAAE,EAAE;QACtF,IAAIN,KAAK,CAACC,IAAI,CAACI,GAAG,CAAC,CAACC,GAAG,CAAC,EAAE,OAAO,KAAK,CAAC,CAAE;MAC3C;MACA,OAAO,IAAI;IACb;IACA,IAAIL,IAAI,CAACK,GAAG,KAAKJ,EAAE,CAACI,GAAG,EAAE;MACvB,KAAK,IAAID,GAAG,GAAGU,IAAI,CAACE,GAAG,CAAChB,IAAI,CAACI,GAAG,EAAEH,EAAE,CAACG,GAAG,CAAC,GAAG,CAAC,EAAEA,GAAG,GAAGU,IAAI,CAACG,GAAG,CAACjB,IAAI,CAACI,GAAG,EAAEH,EAAE,CAACG,GAAG,CAAC,EAAEA,GAAG,EAAE,EAAE;QACtF,IAAIL,KAAK,CAACK,GAAG,CAAC,CAACJ,IAAI,CAACK,GAAG,CAAC,EAAE,OAAO,KAAK,CAAC,CAAE;MAC3C;MACA,OAAO,IAAI;IACb;EACF;;EAEA;EACA,IAAIF,KAAK,CAACQ,WAAW,CAAC,CAAC,KAAK,GAAG,EAAE;IAC/B,MAAMO,OAAO,GAAGJ,IAAI,CAACC,GAAG,CAACd,EAAE,CAACG,GAAG,GAAGJ,IAAI,CAACI,GAAG,CAAC;IAC3C,MAAMe,OAAO,GAAGL,IAAI,CAACC,GAAG,CAACd,EAAE,CAACI,GAAG,GAAGL,IAAI,CAACK,GAAG,CAAC;IAC3C,IAAKa,OAAO,KAAK,CAAC,IAAIC,OAAO,KAAK,CAAC,IAAMD,OAAO,KAAK,CAAC,IAAIC,OAAO,KAAK,CAAE,EAAE;MACxE,OAAO,IAAI;IACb;EACF;;EAEA;EACA,IAAIhB,KAAK,CAACQ,WAAW,CAAC,CAAC,KAAK,GAAG,EAAE;IAC/B,MAAMO,OAAO,GAAGJ,IAAI,CAACC,GAAG,CAACd,EAAE,CAACG,GAAG,GAAGJ,IAAI,CAACI,GAAG,CAAC;IAC3C,MAAMe,OAAO,GAAGL,IAAI,CAACC,GAAG,CAACd,EAAE,CAACI,GAAG,GAAGL,IAAI,CAACK,GAAG,CAAC;IAC3C,IAAIa,OAAO,KAAKC,OAAO,EAAE;MACvB;MACA,IAAIC,OAAO,GAAGnB,EAAE,CAACG,GAAG,GAAGJ,IAAI,CAACI,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;MACxC,IAAIiB,OAAO,GAAGpB,EAAE,CAACI,GAAG,GAAGL,IAAI,CAACK,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;MACxC,IAAID,GAAG,GAAGJ,IAAI,CAACI,GAAG,GAAGgB,OAAO;MAC5B,IAAIf,GAAG,GAAGL,IAAI,CAACK,GAAG,GAAGgB,OAAO;MAC5B,OAAOjB,GAAG,KAAKH,EAAE,CAACG,GAAG,IAAIC,GAAG,KAAKJ,EAAE,CAACI,GAAG,EAAE;QACvC,IAAIN,KAAK,CAACK,GAAG,CAAC,CAACC,GAAG,CAAC,EAAE,OAAO,KAAK,CAAC,CAAE;QACpCD,GAAG,IAAIgB,OAAO;QACdf,GAAG,IAAIgB,OAAO;MAChB;MACA,OAAO,IAAI;IACb;EACF;;EAEA;EACA,IAAIlB,KAAK,CAACQ,WAAW,CAAC,CAAC,KAAK,GAAG,EAAE;IAC/B,IAAIX,IAAI,CAACI,GAAG,KAAKH,EAAE,CAACG,GAAG,IAAIJ,IAAI,CAACK,GAAG,KAAKJ,EAAE,CAACI,GAAG,EAAE;MAC9C,OAAOP,WAAW,CAACC,KAAK,EAAEC,IAAI,EAAEC,EAAE,EAAEC,IAAI,CAAC,CAAC,CAAE;IAC9C;IACA,OAAOJ,WAAW,CAACC,KAAK,EAAEC,IAAI,EAAEC,EAAE,EAAEC,IAAI,CAAC,CAAC,CAAE;EAC9C;;EAEA;EACA,IAAIC,KAAK,CAACQ,WAAW,CAAC,CAAC,KAAK,GAAG,EAAE;IAC/B,MAAMO,OAAO,GAAGJ,IAAI,CAACC,GAAG,CAACd,EAAE,CAACG,GAAG,GAAGJ,IAAI,CAACI,GAAG,CAAC;IAC3C,MAAMe,OAAO,GAAGL,IAAI,CAACC,GAAG,CAACd,EAAE,CAACI,GAAG,GAAGL,IAAI,CAACK,GAAG,CAAC;IAC3C,IAAIa,OAAO,IAAI,CAAC,IAAIC,OAAO,IAAI,CAAC,EAAE;MAChC,OAAO,IAAI;IACb;EACF;EAEA,OAAO,KAAK,CAAC,CAAE;AACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}